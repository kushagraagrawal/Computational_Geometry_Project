<h1 id="computationalgeometryprojectdocumentation">Computational Geometry Project Documentation</h1>

<h2 id="introduction">Introduction</h2>

<p>This project is a part of the coursework for the course <em>Selected Toipcs in Computer Science (CS F441)</em> under the guidance of <em>Dr. Tathagat Ray</em>.</p>

<h2 id="implementation">Implementation</h2>

<h3 id="formingDCEL">The DCEL data structure</h3>

<p>DCEL is a datastructure used to represent a planar subdivision. The main idea in a DCEL is edges are oriented anti-clockwise inside each face. Since an edge borders two faces, each edge is replaced by 2 half edges, one for each face. <br>
</p>


<h3 id="monotonization">Monotonizing the polygon</h3>

<p>Monotonizing a polygon refers to converting a polygon into a y-monotone polygon. This is achieved by constructing a priority queue Q on the vertices and then handling the various types of vertices encountered. The types of vertices that will be encountered are Start Vertex, Split Vertex, Merge Vertex, Regular Vertex. </p>

<p>Algorithm:</p>

<pre>
MAKE_MONOTONE(Point_set):
1.  Construct a priority queue Q on the vertices of P using their Y coordinates as priority. If 2 points have same Y coordinates, then the one with smaller x coordinates has a higher priority.
2.  Initiate an empty balanced binary search tree T.
3.  while Q is not empty:
4.      do remove the vertex vi with the highest priority from Q.
5.        Call the appropriate procedure to handle the vertex depending on its type. Separate routines will handle a start, split, merge and regular vertex.
</pre>

<h3 id="triangulatemonotonepolygon">Triangulate Monotone Polygon</h3>

<p>Triangulate polygon takes y-monotone polygon stored in DCEL and returns its triangulation.</p>

<pre>
TRIANGULATE_MONOTONE_POLYGON(P):

1.     Merge the vertices on the left chain and the vertices on the right chain of P into one sequence, sorted for decreasing Y coordinate. If two vertices have same Y- coordinate, then the left one comes first.Let u1,u2,u3...un.
2.     initialize an empty stack S and push u1 and u2 into it.
3.     for j<-3 to n-1:
4.         do if uj and the vertex on top are in different chains
5.             then pop all vertices from S
6.         			insert into D, a diagonal from uj to each of the popped vertex except the last one (bottom of stack).
7.         	   push u(j-1) and uj into S
8.         else pop one vertex from S
9.     		   pop the other vertices from S, as long as the diagonals from uj to them are inside P. Insert those diagonals into P. Push the first 				   vertex that has been initially popped, back into S.
10. 		   Push uj into S.
11. 	Add diagonals from un to all vertices in stack except the first and last vertices.
</pre>

<h3 id = "status"> Status </h3>
<p>
The balanced binary search tree was implemented using the Standard Template Library (STL). The map data structure was used to implement the binary search tree. The ordering of the binary search tree can be decided by exploiting two facts - firstly, when an edge is inserted its ordering with respect to existing edges does not change until the existing edge is removed and secondly, edges are inserted in descending y-coordinate order of top edge. Thus, if the starting point of the edge lies to the left of an existing edge, the corresponding leaf will also lie to the left of the leaf containing the existing edge. The edge directly to the left of a vertex can be found out by using the lower bound function.</p>
<h2 id="runningtimeanalysis">Running Time Analysis</h2>

<p><img src="images/points.png" alt="Points graph" /></p>

<table><thead>
<tr>
<th>Number of Points</th>
<th>Graham-Scan time (in us)</th>
<th>Andrews time (in us)</th>
<th>Jarvis March time (in us)</th>
</tr>
</thead><tbody>
<tr>
<td>10</td>
<td>58</td>
<td>48</td>
<td>61.2</td>
</tr>
<tr>
<td>100</td>
<td>244</td>
<td>230.4</td>
<td>497.8</td>
</tr>
<tr>
<td>1000</td>
<td>2582</td>
<td>2480.8</td>
<td>8525.4</td>
</tr>
<tr>
<td>10000</td>
<td>19377.2</td>
<td>28994.2</td>
<td>65278.4</td>
</tr>
<tr>
<td>100000</td>
<td>163436.2</td>
<td>210378.2</td>
<td>792890.4</td>
</tr>
<tr>
<td>1000000</td>
<td>1761554.6</td>
<td>2252025.4</td>
<td>8781688.8</td>
</tr>
</tbody></table>

<p>All the three algorithms were made to run on a given number of points 5 times, each time the points  were generated randomly, and the average of the running time was taken. From the graph, it is clear that Andrew’s and Graham Scan Algorithm are taking almost the same time for all the sets of points. On the other hand, Jarvis March on average takes more time than the other two algorithms. This is because the time consuming step in Graham and Andrews algorithm ,which is the step to sort the points , is run only once whereas in case of Jarvis March, the step to compute polar angle, takes the most time and is repeated a lot of times.</p>

<p><img src="images/vertices.png" alt="Vertices graph" /></p>


<table><thead>
<tr>
<th align="right">Number of vertices</th>
<th align="center">Graham-Scan time (in us)</th>
<th align="center">Andrews time (in us)</th>
<th align="center">Jarvis March time (in us)</th>
</tr>
</thead><tbody>
<tr>
<td align="right">10</td>
<td align="center">161413</td>
<td align="center">210374</td>
<td align="center">238600</td>
</tr>
<tr>
<td align="right">100</td>
<td align="center">162104</td>
<td align="center">209545</td>
<td align="center">2369044</td>
</tr>
<tr>
<td align="right">1000</td>
<td align="center">162210</td>
<td align="center">209957</td>
<td align="center">23435829</td>
</tr>
<tr>
<td align="right">10000</td>
<td align="center">159654</td>
<td align="center">209138</td>
<td align="center">246883120</td>
</tr>
</tbody></table>

<p>All the three algorithms were made to run on a given number of points 5 times, each time the points  were generated randomly, and the average of the running time was taken. From the graph, it is clear that Andrew’s and Graham Scan Algorithm are taking almost the same time for all the sets of points.    Also, Andrew’s and Graham Scan Algorithm take almost constant time for all the vertices, further stating that they are not output dependent. Whereas time taking by Jarvis March keeps on increasing for number of vertices, proving that it is an output dependent algorithm.</p>

<h2 id="degeneracy">Degeneracy</h2>

<p>After checking for Degeneracy, the following results were seen-</p>

<ol>
<li> In the case of n (n>2) collinear points, Graham-Scan Algorithm and Andrew's Algorithm only considered the two extreme points for the Convex Hull every time.
   On the other hand, Jarvis-March considered all the collinear points as separate edges. i.e for n collinear points, n-1 edges are made.
</li>
<li> When there are no points in the input, all the three algorithms throw an exception, saying "Input file is empty". </li>
<li> For a single point in our point space, that point is taken as the Convex Hull. </li>
<li> For two points, the line segment connecting the two points is taken as the Convex Hull. </li>
</ol>

<h2 id="robustness">Robustness</h2>

<p>Algorithms in computational geometry are designed under the assumption of exact real arithmetic. However, in practical implementation of such algorithms, floating point arithmetic almost inevitably leads to robustness issues. While computing the Convex Hull of a set of finite points, such issues might lead to a hole or an extra edge in the Convex Hull. Most well-known algorithms use the signed area of three points in particular order to check whether a point lies to the left or right or on the directed line segment from the other two points. Testing whether a point lies to the right or left or on the directed line segment is subjected to numerical inaccuracy because of floating point computations.</p>

<p>In our assignment, we have used the method of signed area to find whether a point should be included in the Convex Hull, depending on whether it lies to the right/left/ or on the directed line segment. We have also used floating point arithmetic to find the minimum polar angle in Jarvis March algorithm, which faces similiar issues.</p>

<p>In order to test our program against robustness issues, we took few points in the cartesian space. Then we took three test cases, we found out that Andrew's Algorithm and Graham scan gave different results. This is due to the flipped ordering of vertices when computing the signed area. As a result of floating point multiplication, there is an error in precision which results in the inaccurate construction of Convex hull.</p>

<p>In order to tackle this problem, we can specify a small value 'epsilon'. If the abosulte value of signed area is less than epsilon, we consider it to be equal to zero. All values greater than epsilon are considered positive and all values less than negative epsilon are considered negative.</p>

<p>Given below are the snapshots of visualization of Convex Hull:-</p>

<table style="width:100%">
  <tr>
      <th>Test</th>
    <th>Graham</th>
    <th>Andrew</th> 
    <th>Jarvis</th>
  </tr>
  <tr>
      <td> 1
    <td><img src = 'images/test1_graham.png', style="width: 200px;"></td>
    <td><img src = 'images/test1_andrew.png', style="width: 200px;"></td></td> 
    <td><img src = 'images/test1_jarvis.png', style="width: 200px;"></td></td>
  </tr>
  <tr>
      <td> 2
    <td><img src = 'images/test2_graham.png', style="width: 200px;"></td>
    <td><img src = 'images/test2_andrew.png', style="width: 200px;"></td></td> 
    <td><img src = 'images/test2_jarvis.png', style="width: 200px;"></td></td>
  </tr>
  <tr>
      <td> 3
    <td><img src = 'images/test3_graham.png', style="width: 200px;"></td>
    <td><img src = 'images/test3_andrew.png', style="width: 200px;"></td></td> 
    <td><img src = 'images/test3_jarvis.png', style="width: 200px;"></td></td>
  </tr>
</table>

<h2 id="generatingandvisualizingtestcasesusingpythonscript">Generating and Visualizing Test Cases using Python Script</h2>

<h3 id="batchprocessingoftestcases">Batch processing of Test Cases</h3>

<p>New test cases can be generated using the <code>test_convex.py</code> script. The <code>test_convex.cpp</code> file is responsible for executing the algorithms. All test cases must stored in <code>&lt;main_folder&gt;/test_convex/</code> as <code>.txt</code> files. New test cases are created in this folder by default. Test cases are in the format as shown below. Each line represents a point with the first term for x-coordinate and the second term for y-coordinate. The two terms must be seperated <em>only</em> by a space.</p>

<pre><code>0.56 0.45
4.5 5.1
100 0.6
1.34 6.7
</code></pre>

<p>There are four options for running the script.</p>

<p><strong>1. Test pre-existing cases</strong></p>

<pre><code>python test_convex.py &lt;executable_name&gt; &lt;algo_name&gt; all-txt
</code></pre>

<p><strong>2. Test on Gaussian distribution</strong></p>

<pre><code>python test_convex.py &lt;executable_name&gt; &lt;algo_name&gt; gaussian &lt;no_of_test_cases&gt; &lt;no_of_sample_pts&gt; &lt;random_seed&gt; &lt;mean&gt; &lt;variance&gt;
</code></pre>

<p><strong>3. Test on Uniform distribution</strong></p>

<pre><code>python test_convex.py &lt;executable_name&gt; &lt;algo_name&gt; uniform &lt;no_of_test_cases&gt; &lt;no_of_sample_pts&gt; &lt;random_seed&gt; &lt;max_value&gt; &lt;min_value&gt;
</code></pre>

<p><strong>4. Test for output sensitive algorithms</strong></p>

<pre><code>python test_convex.py &lt;executable_name&gt; &lt;algo_name&gt; output-sensitive &lt;no_of_test_cases&gt; &lt;no_of_sample_pts&gt; &lt;no_of_hull_vertices&gt;
</code></pre>

<p><strong>NOTE</strong>: The parameter <code>&lt;algo_name&gt;</code> can take the arguments <code>graham</code>, <code>jarvis</code> or <code>andrew</code> to select the algorithm that must be exected.</p>

<h3 id="visualizingtheresults">Visualizing the Results</h3>

<p>To visualize the results, two <code>.txt</code> files are needed: an <code>&lt;input_file&gt;</code> which contains all the points in the sample space and <code>&lt;output_file&gt;</code> that contains all the points on the hull. Then, to visualize the results, simple run:</p>

<pre><code>python plot_convex_hull.py &lt;input_file&gt; &lt;output_file&gt;
</code></pre>

<h2 id="references">References</h2>

<ol>
<li>Introduction to Algorithms, Third Edition, Thomas H. Cormen</li>
<li>A. M. Andrew, "Another Efficient Algorithm for Convex Hulls in Two Dimensions", Info. Proc. Letters 9, 216-219 (1979).</li>
<li>Joseph O'Rourke. 1998. Computational Geometry in C (2nd ed.). Cambridge University Press, New York, NY, USA.</li>
<li>Class notes.</li>
</ol>

